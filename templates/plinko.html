{% extends "base.html" %}

{% block title %}Plinko - Sarcastic Casino{% endblock %}

{% block content %}
<div class="plinko-game-container">
    <!-- Sidebar Controls -->
    <div class="game-sidebar">
        <div class="sidebar-header">
            <h2>Plinko</h2>
        </div>
        
        <div class="controls-section">
            <div class="bet-amount-section">
                <label for="betAmount">Bet Amount</label>
                <div class="bet-input-group">
                    <button class="bet-modifier" onclick="modifyBet(0.5)">½</button>
                    <input type="number" id="betAmount" value="100" min="1" max="10000" step="1">
                    <button class="bet-modifier" onclick="modifyBet(2)">2×</button>
                </div>
            </div>
            
            <div class="quick-bets">
                <button class="quick-bet-btn" onclick="setBetAmount(100)">$100</button>
                <button class="quick-bet-btn" onclick="setBetAmount(500)">$500</button>
                <button class="quick-bet-btn" onclick="setBetAmount(1000)">$1K</button>
                <button class="quick-bet-btn" onclick="setBetAmount(5000)">$5K</button>
            </div>
            
            <div class="risk-section">
                <label>Risk</label>
                <div class="risk-selector">
                    <button class="risk-btn" data-risk="low" onclick="selectRisk('low')">Low</button>
                    <button class="risk-btn active" data-risk="medium" onclick="selectRisk('medium')">Medium</button>
                    <button class="risk-btn" data-risk="high" onclick="selectRisk('high')">High</button>
                </div>
            </div>
            
            <button id="betButton" class="bet-button">
                <span>Bet</span>
            </button>
        </div>
        
        <div class="wallet-info">
            <div class="balance">
                <span class="balance-label">Balance:</span>
                <span class="balance-amount" id="walletBalance">Loading...</span>
            </div>
        </div>
    </div>
    
    <!-- Main Game Area -->
    <div class="game-area">
        <!-- Ball Drop Zone -->
        <div class="ball-drop-zone" id="ballDropZone">
            <!-- Multiple balls will be created dynamically -->
        </div>
        
        <!-- Plinko Board -->
        <div id="plinkoBoard" class="plinko-board">
            <!-- Pegs will be generated by JavaScript -->
        </div>
        
        <!-- Multiplier Slots -->
        <div class="multiplier-slots">
            {% for i in range(board_data.multipliers|length) %}
            <div class="multiplier-slot" 
                 data-multiplier="{{ board_data.multipliers[i] }}"
                 data-slot="{{ i }}"
                 style="background-color: {{ board_data.slot_colors[board_data.multipliers[i]] }};">
                <div class="slot-multiplier">{{ board_data.slot_names[i] }}</div>
            </div>
            {% endfor %}
        </div>
        
        <!-- Results Display Area -->
        <div id="resultsContainer" class="results-container">
            <!-- Multiple result panels will be created dynamically -->
        </div>
    </div>
</div>

<style>
/* Main Container */
.plinko-game-container {
    display: flex;
    min-height: 100vh;
    background: #1a1b23;
    color: white;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

/* Sidebar Controls */
.game-sidebar {
    width: 300px;
    background: #2a2d39;
    padding: 20px;
    border-right: 1px solid #3a3d49;
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.sidebar-header {
    text-align: center;
    margin-bottom: 10px;
}

.controls-section {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.bet-amount-section {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.bet-input-group {
    display: flex;
    align-items: center;
    background: #1a1b23;
    border-radius: 8px;
    padding: 4px;
    margin-bottom: 10px;
}

.bet-input-group input {
    flex: 1;
    background: transparent;
    border: none;
    color: white;
    padding: 12px 16px;
    font-size: 1rem;
    font-weight: 600;
}

.bet-input-group input:focus {
    outline: none;
}

.bet-modifier {
    background: #3a3d49;
    border: none;
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 500;
    transition: all 0.2s ease;
}

.bet-modifier:hover {
    background: #4a4d59;
}

.quick-bets {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 6px;
}

.quick-bet-btn {
    background: #3a3d49;
    border: none;
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 500;
    font-size: 0.85rem;
    transition: all 0.2s ease;
}

.quick-bet-btn:hover {
    background: #4a4d59;
}

/* Risk Section */
.risk-section {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.risk-selector {
    display: flex;
    gap: 8px;
}

.risk-btn {
    flex: 1;
    background: #3a3d49;
    border: none;
    color: white;
    padding: 10px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 500;
    transition: all 0.2s ease;
}

.risk-btn.active {
    background: #00d4aa;
    color: white;
}

.risk-btn:hover:not(.active) {
    background: #4a4d59;
}

/* Bet Button */
.bet-button {
    background: #00d4aa;
    border: none;
    color: white;
    padding: 16px 32px;
    border-radius: 8px;
    font-size: 1.1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    margin-top: auto;
}

.bet-button:hover {
    background: #00c49a;
    transform: translateY(-1px);
}

.bet-button:disabled {
    background: #3a3d49;
    cursor: not-allowed;
    transform: none;
}

/* Game Area */
.game-area {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    background: #1a1b23;
    position: relative;
}

.ball-drop-zone {
    position: relative;
    width: 100%;
    height: 50px;
    display: flex;
    justify-content: center;
    align-items: center;
}

.ball {
    position: absolute;
    width: 12px;
    height: 12px;
    background: radial-gradient(circle at 30% 30%, #ff6b6b, #ee5a52);
    border-radius: 50%;
    border: 1px solid #ff5252;
    box-shadow: 0 0 10px rgba(255, 107, 107, 0.6), inset 0 2px 4px rgba(255, 255, 255, 0.3);
    z-index: 10;
    transition: transform 0.05s ease;
}

/* Multiple balls with different colors */
.ball.ball-1 { 
    background: radial-gradient(circle at 30% 30%, #ff6b6b, #ee5a52);
    box-shadow: 0 0 10px rgba(255, 107, 107, 0.6), inset 0 2px 4px rgba(255, 255, 255, 0.3);
}

.ball.ball-2 { 
    background: radial-gradient(circle at 30% 30%, #4ecdc4, #45b7a8);
    box-shadow: 0 0 10px rgba(78, 205, 196, 0.6), inset 0 2px 4px rgba(255, 255, 255, 0.3);
}

.ball.ball-3 { 
    background: radial-gradient(circle at 30% 30%, #45b7d1, #357abd);
    box-shadow: 0 0 10px rgba(69, 183, 209, 0.6), inset 0 2px 4px rgba(255, 255, 255, 0.3);
}

.ball.ball-4 { 
    background: radial-gradient(circle at 30% 30%, #f9ca24, #f0932b);
    box-shadow: 0 0 10px rgba(249, 202, 36, 0.6), inset 0 2px 4px rgba(255, 255, 255, 0.3);
}

.ball.ball-5 { 
    background: radial-gradient(circle at 30% 30%, #a55eea, #8854d0);
    box-shadow: 0 0 10px rgba(165, 94, 234, 0.6), inset 0 2px 4px rgba(255, 255, 255, 0.3);
}

/* Plinko Board */
.plinko-board {
    width: 800px;
    height: 500px;
    position: relative;
    background: linear-gradient(180deg, #2a2d39 0%, #1a1b23 100%);
    border-radius: 12px;
    border: 2px solid #3a3d49;
    margin: 20px 0;
}

.peg {
    position: absolute;
    width: 6px;
    height: 6px;
    background: #ffd700;
    border-radius: 50%;
    border: 1px solid #ffed4e;
    box-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
    transition: transform 0.1s ease, box-shadow 0.1s ease;
    z-index: 2;
}

.peg:hover {
    box-shadow: 0 0 12px rgba(255, 215, 0, 0.8);
    transform: scale(1.1);
}

/* Multiplier Slots */
.multiplier-slots {
    display: flex;
    gap: 1px;
    margin-top: 10px;
    width: 800px;
}

.multiplier-slot {
    flex: 1;
    height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 6px;
    position: relative;
    transition: all 0.3s ease;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.multiplier-slot:hover {
    transform: scale(1.02);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.multiplier-slot.winning {
    animation: winPulse 0.6s ease-in-out;
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
}

@keyframes winPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

.slot-multiplier {
    color: white;
    font-weight: 600;
    font-size: 0.85rem;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
}

/* Results container for multiple results */
.results-container {
    position: fixed;
    top: 20px;
    right: 20px;
    width: 300px;
    max-height: 80vh;
    overflow-y: auto;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.result-panel {
    background: rgba(42, 45, 57, 0.95);
    border: 1px solid #3a3d49;
    border-radius: 12px;
    padding: 15px;
    color: white;
    backdrop-filter: blur(10px);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    animation: slideInRight 0.3s ease-out;
    opacity: 1;
    transition: opacity 0.3s ease;
}

.result-panel.win {
    border-color: #4ecdc4;
    background: rgba(78, 205, 196, 0.1);
}

.result-panel.lose {
    border-color: #ff6b6b;
    background: rgba(255, 107, 107, 0.1);
}

.result-title {
    font-size: 1.1rem;
    font-weight: bold;
    margin: 0 0 8px 0;
}

.result-message {
    font-size: 0.9rem;
    margin: 0 0 8px 0;
    opacity: 0.8;
}

.win-amount {
    font-size: 1.1rem;
    font-weight: bold;
    color: #4ecdc4;
}

.result-panel.lose .win-amount {
    color: #ff6b6b;
}

@keyframes slideInRight {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

/* Auto-hide animation */
.result-panel.fade-out {
    opacity: 0;
    transform: translateX(100%);
}

/* Responsive Design */
@media (max-width: 1200px) {
    .plinko-board {
        width: 600px;
        height: 400px;
    }
    
    .multiplier-slots {
        width: 600px;
    }
}

@media (max-width: 768px) {
    .plinko-game-container {
        flex-direction: column;
        min-height: auto;
    }
    
    .game-sidebar {
        width: 100%;
        padding: 15px;
    }
    
    .plinko-board {
        width: 100%;
        max-width: 500px;
        height: 350px;
    }
    
    .multiplier-slots {
        width: 100%;
        max-width: 500px;
    }
    
    .quick-bets {
        grid-template-columns: repeat(4, 1fr);
    }
}
</style>

<script>
// Global variables for multiple ball support
let ballCounter = 0;
let activeBalls = new Map();
let boardData = {};
let walletCurrency = 'USD';

// Initialize board data from server
{% if board_data %}
boardData = {{ board_data|tojson|safe }};
{% else %}
boardData = {
    multipliers: [1000, 50, 20, 10, 5, 2, 1, 0.5, 0.3, 0.5, 1, 2, 5, 10, 20, 50, 1000],
    slot_names: ['1000x', '50x', '20x', '10x', '5x', '2x', '1x', '0.5x', '0.3x', '0.5x', '1x', '2x', '5x', '10x', '20x', '50x', '1000x']
};
{% endif %}

// Initialize wallet currency
{% if wallet and wallet.currency %}
walletCurrency = '{{ wallet.currency }}';
{% endif %}

// Initialize the game
document.addEventListener('DOMContentLoaded', function() {
    initializePlinkoBoard();
    initializeControls();
    initializeWalletBalance();
});

function initializePlinkoBoard() {
    const board = document.getElementById('plinkoBoard');
    const rows = 16;
    const boardWidth = board.offsetWidth;
    const boardHeight = board.offsetHeight;
    
    // Clear existing pegs
    board.innerHTML = '';
    
    // Generate pegs in triangular pattern
    for (let row = 0; row < rows; row++) {
        const pegsInRow = row + 1;
        const rowY = (boardHeight / (rows + 1)) * (row + 1);
        
        for (let peg = 0; peg < pegsInRow; peg++) {
            const pegElement = document.createElement('div');
            pegElement.className = 'peg';
            pegElement.setAttribute('data-row', row);
            pegElement.setAttribute('data-peg', peg);
            
            // Calculate peg position for centered triangular arrangement
            const totalSpacing = boardWidth * 0.8;
            const spacing = totalSpacing / Math.max(1, (rows - 1));
            const rowOffset = (boardWidth - ((pegsInRow - 1) * spacing)) / 2;
            const pegX = rowOffset + (peg * spacing);
            
            pegElement.style.left = pegX + 'px';
            pegElement.style.top = rowY + 'px';
            
            board.appendChild(pegElement);
        }
    }
}

function initializeControls() {
    const betInput = document.getElementById('betAmount');
    const dropBtn = document.getElementById('betButton');
    
    // Drop ball button
    dropBtn.addEventListener('click', dropBall);
}

async function dropBall() {
    const betAmount = parseFloat(document.getElementById('betAmount').value);
    if (!betAmount || betAmount <= 0) {
        alert('Please enter a valid bet amount');
        return;
    }
    
    // Create unique ball ID
    ballCounter++;
    const ballId = 'ball-' + ballCounter;
    
    try {
        // Create ball element
        const ball = createBallElement(ballId);
        
        // Start ball animation and API call simultaneously
        const animationPromise = animateBallDrop(ball, ballId);
        const apiPromise = placeBetAPI(betAmount);
        
        // Wait for both to complete
        const results = await Promise.all([animationPromise, apiPromise]);
        const apiResult = results[1];
        
        // Show result
        displayResult(apiResult, ballId);
        updateLocalWalletBalance(apiResult);
        
        // Clean up ball after showing result
        setTimeout(() => {
            if (ball && ball.parentNode) {
                ball.parentNode.removeChild(ball);
            }
            activeBalls.delete(ballId);
        }, 2000);
        
    } catch (error) {
        console.error('Error:', error);
        showErrorResult('An error occurred: ' + error.message, ballId);
    }
}

function createBallElement(ballId) {
    const ballDropZone = document.getElementById('ballDropZone');
    const ball = document.createElement('div');
    
    // Assign ball class with color variation
    const colorClass = 'ball-' + (((ballCounter - 1) % 5) + 1);
    ball.className = 'ball ' + colorClass;
    ball.id = ballId;
    
    // Start at center top
    ball.style.left = '50%';
    ball.style.top = '-10px';
    ball.style.transform = 'translateX(-50%)';
    ball.style.display = 'block';
    
    ballDropZone.appendChild(ball);
    activeBalls.set(ballId, ball);
    
    return ball;
}

async function placeBetAPI(betAmount) {
    const response = await fetch('/api/plinko/bet', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            amount: betAmount,
            risk_level: getCurrentRiskLevel(),
            wallet_id: {{ wallet.wallet_id }}
        })
    });
    
    if (!response.ok) {
        throw new Error('HTTP error! status: ' + response.status);
    }
    
    return await response.json();
}

function animateBallDrop(ball, ballId) {
    return new Promise((resolve) => {
        const board = document.getElementById('plinkoBoard');
        const pegs = document.querySelectorAll('.peg');
        
        // Move ball from ballDropZone to board coordinate system
        board.appendChild(ball);
        
        // Reset ball position to center top of board
        ball.style.left = '50%';
        ball.style.top = '0px';
        ball.style.transform = 'translateX(-50%)';
        
        // Animation parameters
        let currentRow = 0;
        let currentPegIndex = 0;
        const totalRows = 16;
        const boardWidth = board.offsetWidth;
        const boardHeight = board.offsetHeight;
        
        // Organize pegs by row
        const pegsByRow = [];
        for (let row = 0; row < totalRows; row++) {
            pegsByRow[row] = [];
        }
        
        // Group pegs by their row attribute
        pegs.forEach(pegElement => {
            const row = parseInt(pegElement.getAttribute('data-row'));
            const pegIndex = parseInt(pegElement.getAttribute('data-peg'));
            if (row >= 0 && row < totalRows) {
                pegsByRow[row][pegIndex] = pegElement;
            }
        });
        
        const animationInterval = setInterval(() => {
            // Check if ball still exists
            if (!activeBalls.has(ballId)) {
                clearInterval(animationInterval);
                resolve();
                return;
            }
            
            if (currentRow >= totalRows) {
                clearInterval(animationInterval);
                
                // Calculate final slot
                const finalSlotIndex = Math.max(0, Math.min(boardData.multipliers.length - 1, currentPegIndex));
                
                // Animate to final position
                setTimeout(() => {
                    if (activeBalls.has(ballId)) {
                        const slotWidth = 100 / boardData.multipliers.length;
                        const slotCenter = (finalSlotIndex * slotWidth) + (slotWidth / 2);
                        
                        ball.style.top = (boardHeight + 25) + 'px';
                        ball.style.left = slotCenter + '%';
                        ball.style.transform = 'translateX(-50%)';
                        
                        // Highlight winning slot
                        const slots = document.querySelectorAll('.multiplier-slot');
                        if (slots[finalSlotIndex]) {
                            slots[finalSlotIndex].classList.add('winning');
                            
                            setTimeout(() => {
                                slots[finalSlotIndex].classList.remove('winning');
                            }, 800);
                        }
                    }
                    resolve();
                }, 200);
                
                return;
            }
            
            // Get the peg the ball should hit
            const pegsInThisRow = pegsByRow[currentRow];
            if (pegsInThisRow && pegsInThisRow.length > 0) {
                const validPegIndex = Math.max(0, Math.min(pegsInThisRow.length - 1, currentPegIndex));
                const targetPeg = pegsInThisRow[validPegIndex];
                
                if (targetPeg) {
                    // Get peg position (already positioned relative to board)
                    const pegX = parseFloat(targetPeg.style.left);
                    const pegY = parseFloat(targetPeg.style.top);
                    
                    // Position ball at peg center (peg is 6px + 1px border = 8px total, so center is +4px)
                    ball.style.left = (pegX + 4) + 'px';
                    ball.style.top = (pegY + 4) + 'px';
                    ball.style.transform = 'translate(-50%, -50%)';
                    
                    // Visual peg hit effect
                    targetPeg.style.transform = 'scale(1.4)';
                    targetPeg.style.boxShadow = '0 0 15px rgba(255, 215, 0, 1)';
                    
                    setTimeout(() => {
                        targetPeg.style.transform = 'scale(1)';
                        targetPeg.style.boxShadow = '0 0 8px rgba(255, 215, 0, 0.5)';
                    }, 150);
                    
                    // Plinko physics: 50% chance left or right
                    const goRight = Math.random() < 0.5;
                    
                    if (goRight) {
                        currentPegIndex = Math.min(currentRow + 1, currentPegIndex + 1);
                    } else {
                        currentPegIndex = Math.max(0, currentPegIndex);
                    }
                }
            }
            
            currentRow++;
        }, 300);
    });
}

function displayResult(result, ballId) {
    const resultsContainer = document.getElementById('resultsContainer');
    const resultPanel = document.createElement('div');
    
    resultPanel.className = 'result-panel';
    resultPanel.id = 'result-' + ballId;
    
    if (result.success) {
        const currency = result.wallet_currency || walletCurrency || 'USD';
        let symbol;
        switch (currency) {
            case 'EUR': symbol = '€'; break;
            case 'BTC': symbol = '₿'; break;
            case 'USD':
            default: symbol = '$'; break;
        }
        
        if (result.win_amount > 0) {
            resultPanel.classList.add('win');
            resultPanel.innerHTML = 
                '<div class="result-title">🎉 WIN!</div>' +
                '<div class="result-message">Ball landed in ' + result.slot_name + ' slot!</div>' +
                '<div class="win-amount">+' + symbol + result.win_amount.toFixed(2) + '</div>';
        } else {
            resultPanel.classList.add('lose');
            resultPanel.innerHTML = 
                '<div class="result-title">😔 No Win</div>' +
                '<div class="result-message">Ball landed in ' + result.slot_name + ' slot.</div>' +
                '<div class="win-amount">' + symbol + '0.00</div>';
        }
    } else {
        resultPanel.classList.add('lose');
        resultPanel.innerHTML = 
            '<div class="result-title">❌ Error</div>' +
            '<div class="result-message">' + (result.message || 'Something went wrong.') + '</div>' +
            '<div class="win-amount"></div>';
    }
    
    // Add to container
    resultsContainer.appendChild(resultPanel);
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
        if (resultPanel.parentNode) {
            resultPanel.classList.add('fade-out');
            setTimeout(() => {
                if (resultPanel.parentNode) {
                    resultPanel.parentNode.removeChild(resultPanel);
                }
            }, 300);
        }
    }, 5000);
}

function showErrorResult(message, ballId) {
    displayResult({
        success: false,
        message: message
    }, ballId);
}

function updateLocalWalletBalance(result) {
    if (result.success && result.wallet_balance !== undefined) {
        const balanceDisplay = document.getElementById('walletBalance');
        const currency = result.wallet_currency || walletCurrency || 'USD';
        let symbol;
        
        switch (currency) {
            case 'EUR': symbol = '€'; break;
            case 'BTC': symbol = '₿'; break;
            case 'USD':
            default: symbol = '$'; break;
        }
        
        balanceDisplay.textContent = symbol + parseFloat(result.wallet_balance).toFixed(2);
        
        // Call the global updateWalletBalance function to update navbar
        if (typeof window.updateWalletBalance === 'function') {
            window.updateWalletBalance(
                parseFloat(result.wallet_balance), 
                currency, 
                {{ wallet.wallet_id if wallet else 'null' }}
            );
        }
    }
}

function getCurrencySymbol() {
    switch (walletCurrency) {
        case 'EUR': return '€';
        case 'BTC': return '₿';
        case 'USD':
        default: return '$';
    }
}

// Handle window resize
window.addEventListener('resize', () => {
    setTimeout(initializePlinkoBoard, 100);
});

// Utility functions
function modifyBet(multiplier) {
    const betInput = document.getElementById('betAmount');
    const currentAmount = parseFloat(betInput.value) || 0;
    const newAmount = currentAmount * multiplier;
    betInput.value = Math.max(1, Math.round(newAmount));
}

function setBetAmount(amount) {
    document.getElementById('betAmount').value = amount;
}

function selectRisk(riskLevel) {
    // Update active risk button
    document.querySelectorAll('.risk-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    document.querySelector('[data-risk="' + riskLevel + '"]').classList.add('active');
    
    // Update multipliers
    updateMultipliers(riskLevel);
}

function updateMultipliers(riskLevel) {
    fetch('/api/plinko/board-data?risk=' + riskLevel)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const slots = document.querySelectorAll('.multiplier-slot');
                data.board_data.multipliers.forEach((multiplier, index) => {
                    if (slots[index]) {
                        slots[index].setAttribute('data-multiplier', multiplier);
                        slots[index].style.backgroundColor = data.board_data.slot_colors[multiplier];
                        slots[index].querySelector('.slot-multiplier').textContent = multiplier + 'x';
                    }
                });
                
                // Update global board data
                Object.assign(boardData, data.board_data);
            }
        })
        .catch(error => {
            console.error('Error updating multipliers:', error);
        });
}

function getCurrentRiskLevel() {
    const activeRiskBtn = document.querySelector('.risk-btn.active');
    return activeRiskBtn ? activeRiskBtn.getAttribute('data-risk') : 'high';
}

function initializeWalletBalance() {
    const balanceElement = document.getElementById('walletBalance');
    const currency = walletCurrency || 'USD';
    const symbol = getCurrencySymbol();
    
    {% if wallet %}
    const initialBalance = {{ wallet.balance|round(2) }};
    balanceElement.textContent = symbol + initialBalance.toFixed(2);
    {% else %}
    balanceElement.textContent = 'No Wallet';
    {% endif %}
}
</script>
{% endblock %} 